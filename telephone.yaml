esphome:
  name: telephone
  friendly_name: telephone

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "JIfaMgf9LImo+uUI6efK/+1c1v9nYnYNiNFQK56xzYk="

ota:
  - platform: esphome
    password: "28cae50d7289dd27f986761948b7d2dc"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Telephone Fallback Hotspot"
    password: "Ws2cDekp9TIE"

captive_portal:


# -------------------------
# Inputs
# -------------------------

# Analog input for speaker detection
sensor:
  - platform: adc
    pin: GPIO36                 # Adjust to your speaker input pin
    name: "Speaker Voltage"
    id: speaker_voltage
    update_interval: 50ms
    filters:
      - sliding_window_moving_average:
          window_size: 5
          send_every: 1

binary_sensor:
  # Hook switch input
  - platform: gpio
    pin:
      number: GPIO16             # Hook switch GPIO
      mode: INPUT_PULLUP
      inverted: True
    name: "Hook"
    id: hook
    on_press:
      then:
        - script.execute: hook_down
    on_release:
      then:
        - script.execute: hook_up

  # Dial pulse input
  - platform: gpio
    pin:
      number: GPIO4             # Dial pulse GPIO
      mode: INPUT_PULLUP
      inverted: True
    name: "Dial"
    id: dial
    on_press:
      then:
        - script.execute: count_pulses

# -------------------------
# I2C Bus for Keypad (ADG2188)
# -------------------------
i2c:
  sda: 21
  scl: 22
  scan: true
  id: i2c_bus

i2c_device:
  id: i2cdev
  address: 0xE0

# -------------------------
# Outputs (Bell)
# -------------------------
output:
  - platform: gpio
    pin: 25
    id: bell_1

  - platform: gpio
    pin: 26
    id: bell_2

# -------------------------
# Constants
# -------------------------
globals:
  - id: ring_min_voltage
    type: float
    initial_value: "2.0"  # Adjust to your threshold voltage for sound detection

  - id: pulse_count
    type: int
    initial_value: "0"

  - id: pulse_timer_running
    type: bool
    initial_value: "false"

  - id: bell_active # true when the bell is ringing as part of the UK cadence simulation
    type: bool
    initial_value: "false"

  - id: bell_direction # can be either 1 or 2 depending on which direction the bell dinger is pointing
    type: int
    initial_value: "1"
# -------------------------
# Scripts
# -------------------------
interval:
  - interval: 5s
    then:
      - lambda: 'id(key_press).execute("1");'
          
    # 25Hz bell ring
  - interval: 20ms  # Half-period for 25Hz
    then:
      - lambda: |-
          if (id(bell_active)) {
            // Toggle bell_1
            if(id(bell_direction) == 1) {
              id(bell_1).turn_on();
              id(bell_2).turn_off();
              id(bell_direction) = 2; 
            } else {
              id(bell_1).turn_off();
              id(bell_2).turn_on(); 
              id(bell_direction) = 1;
            }
          } else {
            // Ensure both off when not ringing
            id(bell_1).turn_off();
            id(bell_2).turn_off();
          }

    # Sound detection
  - interval: 50ms
    then:
      - lambda: |-
          static bool bell_running = false;
          if (id(hook).state && id(speaker_voltage).state > id(ring_min_voltage)) {
            if (!bell_running) {
              bell_running = true;
              id(ring_bell).execute();
            }
          } else {
            bell_running = false;
          }


script:
    # Press a key on the keypad
  - id: key_press
    parameters:
      key: string
    then:
      - lambda: |- 
          id(i2cdev).write_byte(0x80, 0x01);
          //if (auto b = id(i2cdev).read_byte(0x01)) {
           // TODO
          //}

    # Bell ringing script with UK cadence
  - id: ring_bell
    mode: queued
    then:
      - lambda: 'id(bell_active) = true;'
      - delay: 400ms
      - lambda: 'id(bell_active) = false;'
      - delay: 200ms
      - lambda: 'id(bell_active) = true;'
      - delay: 400ms
      - lambda: 'id(bell_active) = false;'
      - delay: 2000ms
      - while:
          condition:
            lambda: 'return id(hook).state && id(speaker_voltage).state > id(ring_min_voltage);'
          then:
            - script.execute: ring_bell

  # Hang up
  - id: hook_down
    then:
      - logger.log: "Hook DOWN detected"
      - script.execute: 
          id: key_press
          key: "end"
                          
  # Lift receiver
  - id: hook_up
    then:
      - logger.log: "Hook UP detected"
      - if:
          condition: 
            lambda: 'return id(speaker_voltage).state > id(ring_min_voltage);'
          then:
            - script.execute: 
                id: key_press
                key: "talk"

  # Count pulses from dial
  - id: count_pulses
    then:
      - lambda: |-
          if (!id(pulse_timer_running)) {
            id(pulse_count) = 1;
            id(pulse_timer_running) = true;
          } else {
            id(pulse_count) += 1;
          }
      - delay: 1s
      - lambda: |-
          if (id(pulse_timer_running)) {
            ESP_LOGD("main","Dial pulses counted: %d", id(pulse_count));
            // Press intercom button
            id(key_press).execute("intercom");
            // Then press number of pulses
            id(key_press).execute(std::to_string(id(pulse_count)));
          }


